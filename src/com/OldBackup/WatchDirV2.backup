package com.OTDSHCo;
import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;

public class CheckSum
{
	private void meth1() throws NoSuchAlgorithmException,
						IOException
	{
		MessageDigest md=MessageDigest.getInstance("SHA1");
		FileInputStream fis=new FileInputStream("c:\\loging.log");
		byte[] dataBytes=new byte[1024];
		int nread=0;
		while((nread=fis.read(dataBytes))!=-1)
		{
			md.update(	dataBytes,
						0,
						nread);
		}
		byte[] mdbytes=md.digest();
		// convert the byte to hex format method 1
		StringBuffer sb=new StringBuffer();
		for(int i=0; i<mdbytes.length; i++)
		{
			sb.append(Integer.toString(	(mdbytes[i]&0xff)+0x100,
										16)
								.substring(1));
		}
		System.out.println("Digest(in hex format):: "+
							sb.toString());
		// convert the byte to hex format method 2
		StringBuffer hexString=new StringBuffer();
		for(int i=0; i<mdbytes.length; i++)
		{
			String hex=Integer.toHexString(0xff&mdbytes[i]);
			if(hex.length()==1)
				hexString.append('0');
			hexString.append(hex);
		}
		System.out.println("Digest(in hex format):: "+
							hexString.toString());
	}

	private void meth2() throws FileNotFoundException,
						NoSuchAlgorithmException
	{
		MessageDigest digest=MessageDigest.getInstance("SHA1");
		File f=new File("c:\\myfile.txt");
		InputStream is=new FileInputStream(f);
		byte[] buffer=new byte[8192];
		int read=0;
		try
		{
			while((read=is.read(buffer))>0)
			{
				digest.update(	buffer,
								0,
								read);
			}
			byte[] md5sum=digest.digest();
			BigInteger bigInt=new BigInteger(	1,
												md5sum);
			String output=bigInt.toString(16);
			System.out.println("MD5: "+
								output);
		}
		catch(IOException e)
		{
			throw new RuntimeException(	"Unable to process file for MD5",
										e);
		}
		finally
		{
			try
			{
				is.close();
			}
			catch(IOException e)
			{
				throw new RuntimeException(	"Unable to close input stream for MD5 calculation",
											e);
			}
		}
	}

	public void detectLockFile(String lockFilePath) throws IOException
	{
		WatchService watcher=FileSystems.getDefault()
										.newWatchService();
		Path lockFile=Paths.get(lockFilePath);
		Path lockFileDir=lockFile.getParent();
		lockFileDir.register(	watcher,
								ENTRY_CREATE);
		WatchKey watchKey;
		_watchLoop:
		while(!Thread.currentThread()
						.isInterrupted())
		{
			try
			{
				watchKey=watcher.take();
				if(!watchKey.isValid())
				{
					continue;
				}
			}
			catch(InterruptedException e)
			{
				Thread.currentThread()
						.interrupt();
				break;
			}
			final List<WatchEvent<?>> watchEvents=watchKey.pollEvents();
			for(WatchEvent<?> event : watchEvents)
			{
				if(event.kind()
						.equals(ENTRY_CREATE))
				{
					Path createdFileRelativePath=(Path)event.context();
					Path createdFileAbsolultePath=lockFileDir.resolve(createdFileRelativePath);
					if(createdFileAbsolultePath.equals(lockFile))
					{
						System.out.println("Lock file detected !");
					}
				}
			}
			watchKey.reset();
		}
		watcher.close();
	}

	private void otherWay(Path myDir)
	{
		try
		{
			WatchService watcher=myDir.getFileSystem()
										.newWatchService();
			myDir.register(	watcher,
							ENTRY_CREATE,
							ENTRY_DELETE,
							ENTRY_MODIFY);
			for(;;)
			{
				WatchKey watckKey=watcher.take();
				List<WatchEvent<?>> events=watckKey.pollEvents();
				for(WatchEvent<?> event : events)
				{
					if(event.kind()==ENTRY_CREATE)
					{
						log("Created: "+
							event.context()
									.toString());
					}
					if(event.kind()==ENTRY_DELETE)
					{
						log("Delete: "+
							event.context()
									.toString());
					}
					if(event.kind()==ENTRY_MODIFY)
					{
						log("Modify: "+
							event.context()
									.toString());
					}
				}
			}
		}
		catch(Exception e)
		{
			log("Error: "+
				e.toString());
		}
	}

	private void log(String msg)
	{
		System.out.println(msg);
	}
}
